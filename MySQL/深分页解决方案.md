## 深分页的原因：

```sql
select * from table where a = x limit m, n
```

数据量比较大的时候，此种方式的查询效果性能会显著下降
## 性能问题

成因：
- **全表扫描**：当 OFFSET 值增大时，MySQL必须跳过前面的所有记录。这意味着 MySQL 需要对前面的记录进行排序（如果使用 `ORDER BY`），即使这些记录并不在最终结果中。这导致查询的执行时间线性增长。
- **内存消耗**：随着 OFFSET 的增加，MySQL 需要使用更多的内存来存储那些被跳过的记录，尤其在进行排序时，这会对性能产生显著影响。

影响：
- 响应时间延迟
- 数据库负载增加
## 优化策略

1.  基于主键的游标分页（比较依赖主键递增）
通过前端传递最后一条数据id，查询大于此id的数据

2.  分段加载
通过在业务上调整跳页，改成懒加载模式，滚动加载

3. inner join 延迟关联
```sql
select * from table t1 inner join (select id from table where a = x limit m, n) t2 on t1.id = t2.id
```

通过将条件转移到主键树，减少回表降低磁盘IO